# FSTD

### FSTD - Frog Standard

This is my minimal/foundational C++ framework for software development.

#### Docs

##### Vector

    A normal Vector's max capacity is of the type int.
    There are aliases like Vector8, Vector16, Vector32 and Vector64 that
    set the type of the capacity to ui8, ui16, ui32 and ui64 accordingly.
    To see what those types are look into base.h it's just an alias to intN_t.

#### To-do

    [ ] - Implement Vector
        [X] - Implement Push_back()
        [X] - Implement Emplace_back()
        [ ] - Implement Iterator()
        [ ] - Implement Emplace()
        [ ] - Implement Insert()
        [ ] - Implement operators such as [], ==, etc.

        Iterators will be useful for generic implementation of the algorithms
        working on the datastructures.

    Iterator implementation:
        Does the generic implementation of an iterator even makes sense?
        Maybe make general Iterator class with virtual funcitons and then implement
        iterators based on our needs based on Iterator class?
        Why not just implement iterator for each of the types for each of the
        container? Kind of reduntant?

    [ ] - Implement generic accumulate and test the datastructures implementation based on it.

#### Notes

Since I am creating this while reading _A Tour of C++ by Bjarne Stroustrup_,
I will be making notes on stuff I am just learning about and I this this is
just the right place to do it. It's not like I'm new to C++, but I haven't
really grasped all the necessary knowledge yet and I don't like AI writing
"better" code then me. It really isn't better or worse it's just we need to
associate with the code we write and go to the times where the code was art.
And if we don't understand the code generated by the AI soon we won't be thinking
about flying cars, but about that whether a flying car is going to fall on our head
or not, because it has been vibe coded... I am not using any AI generators here though.

##### Concepts

    A concept is a compile-time predicate
        - A function run at compile time yielding a Boolean
        - Takes a set of types and/or values as arguments
        - Use patterns: show what operations you need
        - Handles mixed mode arithmetic and implicit conversions

```C++

    template<typename T, typename U = T>
    concept equality_comparable = requires(T a, U b) {
        {a==b} -> Boolean;
        {a!=b} -> Boolean;
        {b==a} -> Boolean;
        {b!=a} -> Boolean;
    }

```
